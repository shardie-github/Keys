# Cursor Keys: API Route Generation - Mega Prompt
# Unlocks REST API route generation patterns in Cursor

---
name: API Route Generation
description: Generate production-ready REST API routes with CRUD operations, validation, error handling, and proper response formatting
version: 1.0.0

# Context
context:
  framework: "Express.js / Next.js API Routes"
  language: "TypeScript"
  patterns:
    - "RESTful API design"
    - "Request validation with Zod"
    - "Error handling middleware"
    - "Response formatting"
    - "Type-safe routes"

# Instructions
instructions: |
  Generate a complete REST API route handler with the following requirements:

  1. **Route Structure**:
     - Use Express.js Router or Next.js API route handler
     - Follow RESTful conventions (GET, POST, PUT, DELETE)
     - Include proper TypeScript types

  2. **Request Validation**:
     - Use Zod for request body/query/params validation
     - Return 400 Bad Request for invalid input
     - Include descriptive error messages

  3. **Error Handling**:
     - Use try-catch blocks
     - Return appropriate HTTP status codes
     - Include error logging
     - Return consistent error response format

  4. **Response Formatting**:
     - Use consistent response structure: { success: boolean, data?: T, error?: string }
     - Set proper Content-Type headers
     - Include appropriate status codes (200, 201, 204, etc.)

  5. **Database Operations**:
     - Use async/await
     - Handle database errors gracefully
     - Return 404 for not found resources
     - Return 409 for conflicts (e.g., duplicate entries)

  6. **Security**:
     - Validate user authentication (if required)
     - Check authorization/permissions
     - Sanitize inputs
     - Use parameterized queries (prevent SQL injection)

# Examples
examples:
  - name: "GET /api/users/:id"
    code: |
      import { Router } from 'express';
      import { z } from 'zod';
      import { asyncHandler } from '../middleware/errorHandler';
      import { authMiddleware } from '../middleware/auth';

      const router = Router();

      const getUserParamsSchema = z.object({
        id: z.string().uuid(),
      });

      router.get(
        '/users/:id',
        authMiddleware,
        asyncHandler(async (req, res) => {
          const { id } = getUserParamsSchema.parse(req.params);

          const user = await db.users.findById(id);
          if (!user) {
            return res.status(404).json({
              success: false,
              error: 'User not found',
            });
          }

          res.json({
            success: true,
            data: user,
          });
        })
      );

  - name: "POST /api/users"
    code: |
      const createUserSchema = z.object({
        email: z.string().email(),
        name: z.string().min(1).max(100),
        role: z.enum(['user', 'admin']).default('user'),
      });

      router.post(
        '/users',
        authMiddleware,
        asyncHandler(async (req, res) => {
          const userData = createUserSchema.parse(req.body);

          // Check for duplicate email
          const existing = await db.users.findByEmail(userData.email);
          if (existing) {
            return res.status(409).json({
              success: false,
              error: 'Email already exists',
            });
          }

          const user = await db.users.create(userData);

          res.status(201).json({
            success: true,
            data: user,
          });
        })
      );

  - name: "PUT /api/users/:id"
    code: |
      const updateUserSchema = z.object({
        name: z.string().min(1).max(100).optional(),
        role: z.enum(['user', 'admin']).optional(),
      });

      router.put(
        '/users/:id',
        authMiddleware,
        asyncHandler(async (req, res) => {
          const { id } = getUserParamsSchema.parse(req.params);
          const updates = updateUserSchema.parse(req.body);

          const user = await db.users.findById(id);
          if (!user) {
            return res.status(404).json({
              success: false,
              error: 'User not found',
            });
          }

          const updated = await db.users.update(id, updates);

          res.json({
            success: true,
            data: updated,
          });
        })
      );

  - name: "DELETE /api/users/:id"
    code: |
      router.delete(
        '/users/:id',
        authMiddleware,
        asyncHandler(async (req, res) => {
          const { id } = getUserParamsSchema.parse(req.params);

          const user = await db.users.findById(id);
          if (!user) {
            return res.status(404).json({
              success: false,
              error: 'User not found',
            });
          }

          await db.users.delete(id);

          res.status(204).send();
        })
      );

# Patterns
patterns:
  crud:
    - "Create: POST /resource"
    - "Read: GET /resource/:id"
    - "Update: PUT /resource/:id"
    - "Delete: DELETE /resource/:id"
    - "List: GET /resource"

  validation:
    - "Use Zod schemas for all inputs"
    - "Validate params, query, and body separately"
    - "Return 400 with descriptive errors"

  error_handling:
    - "Use asyncHandler wrapper"
    - "Try-catch for database operations"
    - "Log errors for debugging"
    - "Return user-friendly error messages"

  response_format:
    - "Success: { success: true, data: T }"
    - "Error: { success: false, error: string }"
    - "Use appropriate HTTP status codes"

# Best Practices
best_practices:
  - "Always validate input"
  - "Use TypeScript types"
  - "Handle errors gracefully"
  - "Return consistent response format"
  - "Use async/await for database operations"
  - "Check authentication/authorization"
  - "Sanitize user inputs"
  - "Use parameterized queries"
